{"version":3,"sources":["map/Legend.jsx","map/Map.jsx","timeline/Timeline.jsx","FeatureIndex.js","App.js","index.js"],"names":["Legend","props","className","selected","onClick","onSelect","index","markers","map","marker","STYLE_OUTER","stroke","color","weight","opacity","fill","fillColor","fillOpacity","STYLE_INNER","getBounds","geojson","bounds","bbox","slice","reverse","Map","data","timerange","useState","selectedMarker","setSelectedMarker","allFeatures","features","filter","f","geometry","type","getRadius","minWorks","k","maxWorks","d","numWorks","Math","sqrt","radiusFn","featuresToDisplay","min","max","records","r","year","length","MapContainer","preferCanvas","TileLayer","url","feature","allWorks","worksWithMarker","includes","outerRadius","innerRadius","popup","Popup","href","properties","geonames_uri","placename","getFeatureInfo","Fragment","CircleMarker","center","coordinates","radius","pathOptions","Timeline","range","setRange","getLeftPct","style","left","draggableTrack","minValue","maxValue","value","onChange","sanitized","FeatureIndex","findByMarker","_byMarker","maxWorksPerPlace","minWorksPerPlace","Infinity","byMarker","forEach","num_works","Array","from","reduce","acc","work","add","Set","featuresWithMarker","push","this","_features","_maxWorksByPlace","_minWorksByPlace","Object","keys","sort","computeTimeline","years","App","useSWR","fetch","then","json","setTimerange","L","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.70925f8d.chunk.js","sourcesContent":["const Legend = props => {\n\n  return (\n    <div className=\"map-legend\">\n      <table>\n        <tbody>\n          <tr\n            className={props.selected == null ? 'selected' : null} \n            onClick={() => props.onSelect()}>\n            <td>\n              <span className=\"dot\"></span>\n            </td>\n            <td>\n              <label>All works</label>\n            </td>\n          </tr>\n\n          { props.index.markers.map(marker => \n            <tr \n              key={marker} \n              className={props.selected === marker ? 'selected' : null}\n              onClick={() => props.onSelect(marker)}>\n              <td>\n                <span className=\"dot\"></span>\n              </td>\n              <td>\n                <label>{marker}</label>\n              </td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n    </div>\n  )\n\n}\n\nexport default Legend;","import React, { useState } from 'react';\nimport bbox from '@turf/bbox';\nimport { MapContainer, CircleMarker, Popup, TileLayer } from 'react-leaflet';\nimport Legend from './Legend';\n\nimport 'leaflet/dist/leaflet.css';\n\nimport './Map.scss';\n\nconst STYLE_OUTER = {\n  stroke: true,\n  color: '#4e4e4e',\n  weight: 1.5,\n  opacity: 0.65,\n  fill: true,\n  fillColor: '#b7b7b7',\n  fillOpacity: 0.7\n};\n\nconst STYLE_INNER = {...STYLE_OUTER, \n  color: '#bf7814',\n  fillColor: '#ff9a1e', \n  fillOpacity: 1\n};\n\nconst MIN_MARKER_SIZE = 5 * 5;\nconst MAX_MARKER_SIZE = 32 * 32;\n\nconst getBounds = geojson => {\n  const bounds = bbox(geojson);\n  return [\n    bounds.slice(0, 2).slice().reverse(),\n    bounds.slice(2).slice().reverse()\n  ];\n}\n\n/** Helper, so we only compute k & d once, not for every marker **/\nconst radiusFn = index => {\n  const { minWorks, maxWorks } = index;\n\n  const k = (MAX_MARKER_SIZE - MIN_MARKER_SIZE) / (maxWorks - minWorks);\n  const d = MIN_MARKER_SIZE - k * minWorks;\n\n  return numWorks => Math.sqrt(k * numWorks + d);\n}\n\nconst Map = ({ data, index, timerange }) => {\n\n  const [ selectedMarker, setSelectedMarker ] = useState();\n\n  const allFeatures = data?.features.filter(f => f?.geometry.type === 'Point');\n\n  const getRadius = index && radiusFn(index);\n\n  const featuresToDisplay = timerange ? allFeatures.filter(f => {\n    const { min, max } = timerange;\n\n    const worksInRange = f.records\n      .filter(r => r.year >= min && r.year <= max);\n  \n    return worksInRange.length > 0; \n  }) : allFeatures;\n\n  const getFeatureInfo = feature => {\n    const allWorks = timerange ? feature.records\n      .filter(r => r.year >= timerange.min && r.year <= timerange.max) : feature.records;\n\n    const worksWithMarker = selectedMarker ? \n      allWorks.filter(r => r.markers.includes(selectedMarker)) : allWorks;\n\n    const outerRadius = getRadius(allWorks.length);\n    const innerRadius = worksWithMarker.length > 0 ? getRadius(worksWithMarker.length) : 0;\n\n    const popup = \n      <Popup>\n        <h1><a href={feature.properties.geonames_uri}>{feature.properties.placename}</a></h1>\n        { selectedMarker  ?\n          <>\n            <p>{worksWithMarker.length} works '{selectedMarker}'</p>\n            <p>{allWorks.length} works total</p>\n          </> : \n          <p>{allWorks.length} works</p>\n        }\n      </Popup>\n\n    return { outerRadius, innerRadius, popup };\n  }\n\n  return (\n    <>\n      { featuresToDisplay &&\n        <>\n          <MapContainer bounds={getBounds(data)} preferCanvas={true}>\n            <TileLayer url=\"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\" />\n\n            { featuresToDisplay.map(f => {\n              const { outerRadius, innerRadius, popup } = getFeatureInfo(f);\n              return (\n                <React.Fragment key={f.properties.placename}>\n                  <CircleMarker\n                    key={`${f.properties.placename}-outer`}\n                    center={f.geometry.coordinates.slice().reverse()}\n                    radius={outerRadius}\n                    pathOptions={STYLE_OUTER}>\n                    \n                    {popup}\n\n                  </CircleMarker>\n\n                  { selectedMarker && innerRadius > 0 && \n                    <CircleMarker \n                      key={`${f.properties.placename}-inner`} \n                      center={f.geometry.coordinates.slice().reverse()}\n                      radius={innerRadius}\n                      pathOptions={STYLE_INNER}>\n                      \n                      { popup }\n\n                    </CircleMarker>\n                  }\n                </React.Fragment>\n              )\n            })}\n          </MapContainer>\n\n          <Legend\n            index={index} \n            selected={selectedMarker}\n            onSelect={marker => setSelectedMarker(marker) }/>\n        </>\n      }\n    </>\n  )\n\n}\n\nexport default Map;","// Cf. https://github.com/davidchin/react-input-range\nimport InputRange from 'react-input-range';\nimport { useState } from 'react';\n\nimport './Timeline.scss';\n\nimport 'react-input-range/lib/css/index.css';\n\nconst Timeline = props => {\n  \n  // Start and end years\n  const min = props.data[0];\n  const max = props.data[props.data.length - 1];\n\n  const [ range, setRange ] = useState({ min, max});\n\n  const getLeftPct = year =>\n    100 * ((year - min) / (max - min))\n\n  const onChange = value => {\n    const sanitized = {\n      min: Math.max(min, value.min),\n      max: Math.min(max, value.max)\n    };\n\n    setRange(sanitized);\n    props.onChange(value);\n  }\n\n  return (\n    <div className=\"t6e-timeline\">\n      <div className=\"t6e-timeline-inner\">\n        <div className=\"t6e-ticks\">\n          { props.data.map(year =>\n            <div key={year} className=\"t6e-tick-wrapper\" style={{ left: `${getLeftPct(year)}%` }}>\n              <div className=\"t6e-tick\" />\n            </div>\n          )}\n        </div>\n        <InputRange\n          draggableTrack\n          minValue={min}\n          maxValue={max}\n          value={range}\n          onChange={onChange} />\n      </div>\n    </div>\n  )\n\n}\n\nexport default Timeline;","/** \n * Returns the list of distinct markers from all \n * works at this feature.\n */\nconst getMarkers = feature =>\n  Array.from(\n    feature.records.reduce((acc, work) => {\n      work.markers.forEach(marker => acc.add(marker));\n      return acc;\n    }, new Set())\n  );\n\nexport default class FeatureIndex {\n\n  constructor(geojson) {\n    const features = geojson.features.filter(f => f?.geometry.type === 'Point');\n\n    let maxWorksPerPlace = 0;\n    let minWorksPerPlace = Infinity;\n\n    // For later optimizations: index features by metadata marker\n    const byMarker = {};\n\n    features.forEach(f => {\n      const { num_works } = f.properties;\n\n      if (num_works > maxWorksPerPlace)\n        maxWorksPerPlace = num_works;\n\n      if (num_works < minWorksPerPlace)\n        minWorksPerPlace = num_works;\n\n      getMarkers(f).forEach(marker => {\n        const featuresWithMarker = byMarker[marker];\n        if (featuresWithMarker) {\n          featuresWithMarker.push(f);\n        } else {\n          byMarker[marker] = [ f ];\n        }\n      })\n    });\n\n    this._features = features;\n    this._maxWorksByPlace = maxWorksPerPlace;\n    this._minWorksByPlace = minWorksPerPlace;\n    this._byMarker = byMarker;\n  }\n\n  get features() {\n    return this._features;\n  } \n\n  /**\n   * The maximum number of works that exist at any place.\n   */\n  get maxWorks() {\n    return this._maxWorksByPlace;\n  }\n\n  /** \n   * The minimum number of works that exist at any place.\n   * \n   * Probably always 1, but for completeness...\n   */\n  get minWorks() {\n    return this._minWorksByPlace;\n  }\n\n  get markers() {\n    return Object.keys(this._byMarker).slice().sort();\n\n  }\n  \n  /** Returns all features with the given marker **/\n  findByMarker = marker =>\n    this._byMarker[marker];\n\n}","import { useState } from 'react';\nimport useSWR from 'swr';\nimport Map from './map/Map';\nimport Timeline from './timeline/Timeline';\nimport FeatureIndex from './FeatureIndex';\n\nimport './App.css';\n\nconst computeTimeline = data => {\n  const reducer = (acc, feature) => {\n    feature.records.forEach(r => { \n      if (r.year)\n        acc.add(r.year);\n    });\n\n    return acc;\n  }\n\n  const years = data.features.reduce(reducer, new Set());\n\n  // To array and sort\n  return [ ...Array.from(years).slice().sort() ];\n}\n\nconst App = () => {\n\n  const { data } = useSWR('map.json', url => fetch(url).then(r => r.json()));\n\n  const [ timerange, setTimerange ] = useState();\n\n  const index = data ? new FeatureIndex(data) : null;\n\n  const onChange = range =>\n    setTimerange(range);\n\n  return (\n    <div className=\"App\">\n      <Map data={data} index={index} timerange={timerange} />\n      { data && \n        <Timeline data={computeTimeline(data)} onChange={onChange} />\n      }\n    </div>\n  );\n\n}\n\nexport default App;\n","import ReactDOM from 'react-dom';\nimport App from './App';\nimport L from 'leaflet';\n\n// Fix missing Leaflet marker images\n// Cf. https://github.com/PaulLeCam/react-leaflet/issues/453\ndelete L.Icon.Default.prototype._getIconUrl;\n\nL.Icon.Default.mergeOptions({\n    iconRetinaUrl: 'images/leaflet/marker-icon-2x.png',\n    iconUrl: 'images/leaflet/marker-icon.png',\n    shadowUrl: 'images/leaflet/marker-shadow.png'\n});\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}